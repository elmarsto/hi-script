(*******************************************************
 *  Hanoi BNF -- core language						   * 
 *******************************************************) 

(**** GRAMMAR ****)

(*in the beginnning....*)
<expression>			::= <statement>+ 
<statement>				::= <declaration> | <thunk> | <forcing> |  e 


(*grammar for binding values*)
<declaration>			::= <when> | <let>
<when>					::= <when-lit> <thunk> <do-lit> <thunk> | 
							<when-lit> <between-lit> <thunk> <do-lit> <thunk> | 
							<whenever-lit> <thunk> <do-lit> <thunk>
<let>					::= <lvalue> <assignment-oper> <rvalue>
<lvalue>				::= <lvalue-first-char>(<lvalue-later-char>*) | 
<rvalue>				::= <thunk> | <forcing> 

(* grammar for thunking, aka creating deferred computations (promises) *)
<thunk>					::= <grouped-thunk> | <concatted-thunk> | <composed-thunk> | <lvalue>
<grouped-thunk>			::= <open-group-oper> <expression>  <close-group-oper>
<concatted-thunk>		::= <statement> (<concat-oper> <statement>)+ 
<composed-thunk>		::= <vanilla-comp> | <array-comp> | <hash-comp> | <filter-comp>
<vanilla-comp>			::= <thunk> <vanilla-comp-oper> <thunk>
<array-comp>			::= <thunk> <array-comp-oper> <thunk>
<hash-comp>				::= <thunk> <hash-comp-oper>  <thunk> 
<filter-comp>			::= <thunk> <filter-comp-oper>  <thunk> 

(* grammar for values, aka forced entities, aka push values, aka computation results, aka literals *)
<forcing>				::= <bare-force> | <force-with-args> | <implied-force>
<bare-force>			::= <thunk> <force-bare-oper>
<force-with-args>		::= <thunk> <force-args-oper>  <thunk>  (* second thunk == args *)
<implied-force>			::= <operation> | <atom> 
<atom>					::= <number> | <character> | <boolean> | <string> 
<operation>				::= <io-op> | <stack-op>
<stack-op>				::= <pop> | <drop> | <swap> | <depth> (* recall no push *)
<io-op>					::= <in> | <out> 


(**** SYNTAX ****) 

(* syntax for literals *) 
<string>				::= <double-quote-lit> <any-unicode-char>* <double-quote-lit>  |
							<single-quote-lit> <any-unicode-char>{2,} <single-quote-lit> 

<character>				::= <single-quote-lit> <any-unicode-char> <single-quote-lit>	| 
							<escape-char> <escaped-char-code>    				|	
							<unicode-escape-prefix> <hexa>{4}    				| 
							<xml-escape-prefix> <deca>+	<xml-escape-suffix>		| 
							(<escape-char>(<octa>{3})){2}


<boolean>				::= "true" | "false" 
<escape-char>			::= "\"
<escaped-char-code>		::= "n" | "r" | "0" 
<unicode-escape-prefix>	::= "U+"
<xml-escape-prefix> 	::= "&#"
<xml-escape-suffix> 	::= ";"
<single-quote-lit>		::= "'"
<double-quote-lit>		::= '"'


(* syntax for numbers *) 
<number>				::= <decimal> | <hexadecimal> | <octal>
<octal>					::= <octa>+
<decimal>				::= <integer> | <float> 
<float>					::= <integer> "." <positive> ("e" <integer>)?
<integer>				::= <negative> | <positive>
<positive>				::= <deca>+ 
<negative>				::= "-" <positive> 
<hexadecimal>			::= "0x" <hexa>+


(* syntax for assignments *)


<when-lit>				::= "when"
<whenever-lit>			::= "whenever"
<between-lit>			::= "between"
<do-lit>				::= "do"

<assignment-oper>		::= "="


(* syntax for thunking *) 
<open-group-oper>		::= "("
<close-group-oper>		::= ")"
<concat-oper>			::= "&"

(* syntax for forcing *)
<force-bare-oper>		::= "!"
<force-args-oper>		::= "?"

(* syntax for stack operations *)
<pop>					::= "_" 
<swap>					::= "^"
<drop>					::= "~"
<depth>					::= "#"

(* syntax for I/O operations *)
<in>					::= "<"
<out>					::= ">"

(* syntax for composition *) 
<vanilla-comp-oper>		::= ":"
<array-comp-oper>		::= "@"
<hash-comp-oper>		::= "%"
<filter-comp-oper>		::= "|"

(* regular expressions for character classes*)
<lvalue-first-char>		::= <alpha> | <deca>
<lvalue-later-char>		::= <alpha> 
<lvalue-oper-char>		::= <oper>
<any-unicode-char>		::= /./
<deca>					::= /[0-9]/
<hexa>					::= /[A-Fa-f0-9]/
<octa>					::= /[0-7]/
<alpha>					::= /[A-Za-z]/
<alnum>					::= /[A-Za-z0-9/
<oper>					::= (* FIXME *) 
